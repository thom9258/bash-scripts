#!/bin/bash

##############################################################################################
# How to use:
#
# -d            Debugging, prints out backup file name and backup directory.
# -b            Force no backup. Used for testing, without creating a backup file
# -f            Force backup, even if force no backup mark exists. See (1)
# -l            list backup directory
#
#
# (1) To make use of the force no backup function. insert the mark (((FORCE_NO_BACKUP))) 
#     anywhere in the file you want to no backup.
#
##############################################################################################

# Make sure a input is given
(( ! $# )) && echo "No argument supplied!" && exit 1

# Variables
BACKUPDIR="$HOME/Backup/"
DEBUG=0
NO_BACKUP=0
FORCE_BACKUP=0
NO_BACKUP_SIGNATURE="(((FORCE_NO_BACKUP)))"

# Manage opts
while getopts "dbfl" opt
do
    case ${opt} in
        d ) DEBUG=1 && shift $((OPTIND-1)) ;;
        b ) echo "Forced no backup!" && NO_BACKUP=1 && shift $((OPTIND-1)) ;;
        f ) echo "Forced backup!" && FORCE_BACKUP=1 && shift $((OPTIND-1)) ;;
        l ) ls --group-directories-first --color=always "$BACKUPDIR" && shift $((OPTIND-1)) ;;
        \? ) echo "Argument not understood, terminating" && exit 1 ;;
    esac
done

# manage input files
for VAR in "$@"
do
    [[ ! -f "$VAR" ]] && echo "Not a file!" && exit 1

    # Check for force no backup signature in file and exit
    (( ! "$FORCE_BACKUP" )) && grep -n "$NO_BACKUP_SIGNATURE" < "$VAR" &&  echo "Forced no backup because (((FORCE_NO_BACKUP))) mark exists in file" && exit 0

    # Create pathname for the backup file
    PATHNAME=$(tr "/" "%" <<< $(realpath "$VAR")) 
    DATE=$(date +%Y-%m-%d.%H:%M:%S)
    BACKUPNAME="$DATE-$PATHNAME"

    # make sure the backup file isn't executable and move it
    cp "$VAR" "$BACKUPNAME"
    chmod -x "$BACKUPNAME"
    mv "$BACKUPNAME" "$BACKUPDIR."
    (( $DEBUG )) && echo "Created file $BACKUPDIR$BACKUPNAME"
done
exit 0
